{"version":3,"sources":["utils/getTokenList.ts","utils/uriToHttp.ts","utils/ENS/parseENSAddress.ts","utils/contenthashToUri.ts"],"names":["tokenListValidator","Ajv","allErrors","compile","schema","getTokenList","listUrl","resolveENSContentHash","a","parsedENS","parseENSAddress","ensName","contentHashUri","console","error","Error","translatedUri","contenthashToUri","urls","uriToHttp","ensPath","i","length","url","isLast","response","fetch","ok","json","validationErrors","errors","reduce","memo","add","dataPath","message","uri","split","toLowerCase","substr","hash","match","name","ENS_NAME_REGEX","ensAddress","UTF_8_DECODER","TextDecoder","contenthash","buff","hex","startsWith","arr","Uint8Array","parseInt","hexToUint8Array","codec","getCodec","data","rmPrefix","cid","CID","toB58String","multihash","decode","digest","trim"],"mappings":"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","file":"static/js/42.5f057085.chunk.js","sourcesContent":["/* eslint-disable no-continue */\n/* eslint-disable no-await-in-loop */\nimport { TokenList } from '@uniswap/token-lists'\nimport schema from '@uniswap/token-lists/src/tokenlist.schema.json'\nimport Ajv from 'ajv'\nimport contenthashToUri from './contenthashToUri'\nimport { parseENSAddress } from './ENS/parseENSAddress'\nimport uriToHttp from './uriToHttp'\n\nconst tokenListValidator = new Ajv({ allErrors: true }).compile(schema)\n\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */\nexport default async function getTokenList(\n  listUrl: string,\n  resolveENSContentHash: (ensName: string) => Promise<string>,\n): Promise<TokenList> {\n  const parsedENS = parseENSAddress(listUrl)\n  let urls: string[]\n  if (parsedENS) {\n    let contentHashUri\n    try {\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName)\n    } catch (error) {\n      console.error(`Failed to resolve ENS name: ${parsedENS.ensName}`, error)\n      throw new Error(`Failed to resolve ENS name: ${parsedENS.ensName}`)\n    }\n    let translatedUri\n    try {\n      translatedUri = contenthashToUri(contentHashUri)\n    } catch (error) {\n      console.error('Failed to translate contenthash to URI', contentHashUri)\n      throw new Error(`Failed to translate contenthash to URI: ${contentHashUri}`)\n    }\n    urls = uriToHttp(`${translatedUri}${parsedENS.ensPath ?? ''}`)\n  } else {\n    urls = uriToHttp(listUrl)\n  }\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const isLast = i === urls.length - 1\n    let response\n    try {\n      response = await fetch(url)\n    } catch (error) {\n      console.error('Failed to fetch list', listUrl, error)\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    const json = await response.json()\n    if (!tokenListValidator(json)) {\n      const validationErrors: string =\n        tokenListValidator.errors?.reduce<string>((memo, error) => {\n          const add = `${(error as any).dataPath} ${error.message ?? ''}`\n          return memo.length > 0 ? `${memo}; ${add}` : `${add}`\n        }, '') ?? 'unknown error'\n      throw new Error(`Token list failed validation: ${validationErrors}`)\n    }\n    return json as TokenList\n  }\n  throw new Error('Unrecognized list URL protocol.')\n}\n","/* eslint-disable no-case-declarations */\n/**\n * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content\n * @param uri to convert to fetch-able http url\n */\nexport default function uriToHttp(uri: string): string[] {\n  const protocol = uri.split(':')[0].toLowerCase()\n  switch (protocol) {\n    case 'https':\n      return [uri]\n    case 'http':\n      return [`https${uri.substr(4)}`, uri]\n    case 'ipfs':\n      const hash = uri.match(/^ipfs:(\\/\\/)?(.*)$/i)?.[2]\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`]\n    case 'ipns':\n      const name = uri.match(/^ipns:(\\/\\/)?(.*)$/i)?.[2]\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`]\n    default:\n      return []\n  }\n}\n","const ENS_NAME_REGEX = /^(([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\\.)+)eth(\\/.*)?$/\n\nexport function parseENSAddress(ensAddress: string): { ensName: string; ensPath: string | undefined } | undefined {\n  const match = ensAddress.match(ENS_NAME_REGEX)\n  if (!match) return undefined\n  return { ensName: `${match[1].toLowerCase()}eth`, ensPath: match[4] }\n}\n\nexport default parseENSAddress\n","import CID from 'cids'\nimport { getCodec, rmPrefix } from 'multicodec'\nimport { decode, toB58String } from 'multihashes'\n\nfunction hexToUint8Array(hex: string): Uint8Array {\n  // eslint-disable-next-line no-param-reassign\n  hex = hex.startsWith('0x') ? hex.substr(2) : hex\n  if (hex.length % 2 !== 0) throw new Error('hex must have length that is multiple of 2')\n  const arr = new Uint8Array(hex.length / 2)\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = parseInt(hex.substr(i * 2, 2), 16)\n  }\n  return arr\n}\n\nconst UTF_8_DECODER = new TextDecoder()\n\n/**\n * Returns the URI representation of the content hash for supported codecs\n * @param contenthash to decode\n */\nexport default function contenthashToUri(contenthash: string): string {\n  const buff = hexToUint8Array(contenthash)\n  const codec = getCodec(buff as Buffer) // the typing is wrong for @types/multicodec\n  switch (codec) {\n    case 'ipfs-ns': {\n      const data = rmPrefix(buff as Buffer)\n      const cid = new CID(data)\n      return `ipfs://${toB58String(cid.multihash)}`\n    }\n    case 'ipns-ns': {\n      const data = rmPrefix(buff as Buffer)\n      const cid = new CID(data)\n      const multihash = decode(cid.multihash)\n      if (multihash.name === 'identity') {\n        return `ipns://${UTF_8_DECODER.decode(multihash.digest).trim()}`\n      }\n      return `ipns://${toB58String(cid.multihash)}`\n    }\n    default:\n      throw new Error(`Unrecognized codec: ${codec}`)\n  }\n}\n"],"sourceRoot":""}